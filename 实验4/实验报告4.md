# 计算机网络实验报告

05-switching

雷正宇 2016K8009909005

# 实验内容

实现对数据结构mac_port_map的所有操作，以及数据包的转发和广播操作

```
iface_info_t *lookup_port(u8 mac[ETH_ALEN]);
void insert_mac_port(u8 mac[ETH_ALEN], iface_info_t *iface);
int sweep_aged_mac_port_entry();
void broadcast_packet(iface_info_t *iface, const char *packet, int len);
void handle_packet(iface_info_t *iface, char *packet, int len);
```

使用iperf和给定的拓扑进行实验，对比交换机转发与集线器广播的性能

# 实验流程

## 实现查找函数

```c
iface_info_t *lookup_port(u8 mac[ETH_ALEN])
{
	int len = sizeof(u8) * ETH_ALEN;
	iface_info_t *ans = NULL;
	pthread_mutex_lock(&mac_port_map.lock);
	mac_port_entry_t *mac_pos = NULL;
	list_for_each_entry(mac_pos, &mac_port_map.hash_table[hash8((char *)mac, len)], list) {
		if (memcmp(mac, mac_pos->mac, len) == 0) {
			mac_pos->visited = time(0);
			ans = mac_pos->iface;
			break;
		}
	}
	pthread_mutex_unlock(&mac_port_map.lock);
	return ans;
}
```

这个函数要实现的功能是在 mac_port_map.hash_table 中通过 mac 地址查询对应端口。按照上述实现，最终该函数的功能是：如果在哈希中找到了对应的项，就将 visited 更新为当前时间，并把结果返回；否则返回空指针。

## 实现插入函数

```c
void insert_mac_port(u8 mac[ETH_ALEN], iface_info_t *iface)
{
	mac_port_entry_t *new_port = malloc(sizeof(mac_port_entry_t));
	new_port->iface = iface;
	memcpy(new_port->mac, mac, sizeof(u8) * ETH_ALEN);
	new_port->visited = time(0);

	pthread_mutex_lock(&mac_port_map.lock);
	list_add_tail(&new_port->list, &mac_port_map.hash_table[hash8((char *)mac, sizeof(u8) * ETH_ALEN)]);
	pthread_mutex_unlock(&mac_port_map.lock);
}
```

该函数主要是在交换机学习时使用，功能是将一个 <mac, 端口> 键值对插入 mac_port_map.hash_table 中。由于 mac_port_map.hash_table 的每一项都是使用的 Linux 风格链表，所以直接使用 list_add_tail 函数就可以简单地完成插入功能。

## 实现老化函数

```c
int sweep_aged_mac_port_entry()
{
	mac_port_entry_t *pos, *q;
	time_t now = time(NULL);
	int count = 0;

	pthread_mutex_lock(&mac_port_map.lock);
	for (int i = 0; i < HASH_8BITS; i++) {
		list_for_each_entry_safe(pos, q, &mac_port_map.hash_table[i], list) {
			if (now - pos->visited >= MAC_PORT_TIMEOUT) {
				list_delete_entry(&pos->list);
				free(pos);
				count++;
			}
		}
	}
	pthread_mutex_unlock(&mac_port_map.lock);

	return count;
}
```

这个函数每次被调用后，会检查 mac_port_map.hash_table 中的所有键值对，如果发现其中有超过 30 秒没有被访问到的项（visited 距离现在时间超过 30）就会将它从链表中删除。最后返回被删除节点的数量。

## 实现广播函数

```c
void broadcast_packet(iface_info_t *iface, char *packet, int len)
{
	iface_info_t *pos = NULL;
	list_for_each_entry(pos, &instance->iface_list, list) {
		if (pos != iface)
			iface_send_packet(pos, packet, len);
	}
}
```

广播函数直接用上周实验的代码即可。

## 实现包处理逻辑

```c
void handle_packet(iface_info_t *iface, char *packet, int len)
{
	struct ether_header *eh = (struct ether_header *)packet;

	if (lookup_port(eh->ether_shost) == NULL) {
		insert_mac_port(eh->ether_shost, iface);
	}

	iface_info_t *find_result = lookup_port(eh->ether_dhost);
	if (find_result != NULL) {
		iface_send_packet(find_result, packet, len);
	} else {
		broadcast_packet(iface, packet, len);
	}
}
```

主要逻辑为：当收到一个包时，在哈希中对其源地址进行检索。检索过程中，如果找到了对应的项，就会将其更新；否则就进行学习——把源地址和端口的键值对插入哈希中。

然后在哈希中对目的地址进行检索，如果找到了对应的端口，就向这个端口发送包，检索过程中会对这一项进行更新；否则就广播这个包。

## 修改启动脚本

启动脚本仅需要把原脚本中的

```python
s1.cmd('./switch-reference &')
```

替换为自己制作的 switch 即可：

```python
s1.cmd('./switch &')
```

# 实验结果和分析

以下是本次试验中使用 switch 得到的 iperf 测试结果：

![image-20190403203141325](/Users/zhengyu/Documents/课件/网络实验/资源/image-20190403203141325.png)

对比上周使用 hub 广播的测试结果：

![image-20190326204404481](/Users/zhengyu/Documents/课件/网络实验/资源/image-20190326204404481.png)

可以看出，在带宽都为 10 Mbps 的情况下，switch 的效率略高于 hub.