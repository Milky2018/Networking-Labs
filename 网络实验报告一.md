# 网络实验报告一

雷正宇 2016K8009909005 3月12日

## 互联网协议实验

### 实验内容

打开 mininet, 在节点 h1 上开启 wireshark 抓包，用 wget 下载 www.baidu.com，观察 wireshark 的输出并分析。

### 实验流程

在 Linux 环境下键入命令：

```
$ sudo mn --nat
```

然后在 mininet 窗口键入：

```
mininet> xterm h1
```

在 h1 节点中将地址 8.8.8.8 配置到解析配置表：

```
h1 # echo "nameserver 1.2.4.8"
```

在 h1 节点打开 wireshark 窗口：

```
h1 # wireshark &
```

在 h1 用 wget 下载 www.baidu.com，同时在 wireshark 观察输出。

### 实验结果及分析

配合截图来分析输出：

![image-20190313155540582](/Users/zhengyu/Documents/课件/网络实验/资源/image-20190313155540582.png)

#### ARP协议包

首先查看截图中ARP协议的两个包：

![image-20190313160025178](/Users/zhengyu/Documents/课件/网络实验/资源/image-20190313160025178.png)

第一个包的具体内容如下：

![image-20190313160540992](/Users/zhengyu/Documents/课件/网络实验/资源/image-20190313160540992.png)

结合 ARP 协议工作的过程：每台主机或路由器在其内存中具有一个 ARP 表，这张表包含 IP 地址到 MAC 地址的映射关系。如果发送方（本例为 ca:07:70:5e:3a:99）的 ARP 表具有该目的节点的表项，这个任务是很容易完成的。而此时这个 ARP 表其实并没有目的主机的表项，通过包中的这个部分内容就能看出：

![image-20190313161052632](/Users/zhengyu/Documents/课件/网络实验/资源/image-20190313161052632.png)

此时发送方用 ARP 协议来解析这个地址。首先，发送方构造一个 ARP 分组。一个 ARP 分组有几个字段，包括发送喝接收 IP 地址及 MAC 地址。ARP 查询分组喝响应分组都有相同的格式。ARP 查询分组的目的是询问子网上所有其他主机和路由器，以确定对应于要解析的 IP 地址的 MAC 地址。

接下来看第二个 ARP 包：

![image-20190313161530192](/Users/zhengyu/Documents/课件/网络实验/资源/image-20190313161530192.png)

之前第一个 ARP 包被其他适配器接收到，并且每个适配器都把 ARP 分组向上传递给 ARP 模块。这里，MAC 地址 6a:7f:23:bd:f7:5f 有 10.0.0.1 这个 IP，IP 地址匹配成功后按照上一个 ARP 包的请求，把这个有效的 ARP 分组传递回去。

#### DNS协议包

DNS 是域名系统，可以简单的将 DNS 请求包和响应包看成是客户端在 DNS 服务器（一个庞大的数据库）通过主机名查询其 IP 地址。关于 DNS 包，本例中有两对：

![image-20190313215012985](/Users/zhengyu/Documents/课件/网络实验/资源/image-20190313215012985.png)

其中 1, 3 是一个请求-响应对，2, 4 是一个请求-响应对。简单地看第3个包对第1个包的请求作出的回应：

![image-20190313215200479](/Users/zhengyu/Documents/课件/网络实验/资源/image-20190313215200479.png)

在 Answers 部分可以看到，DNS 服务器连续查询了 www.baidu.com 的几个同名主机名，最终查询到 www.wshifen.com （据说这是百度的竞分系统遗留下来的域名，但并不能通过该域名打开网页）的 IP 为 103.235.46.39.

#### HTTP和TCP

HTTP 是 Web 的应用层协议，HTTP 使用 TCP 作为它的支撑运输协议。HTTP 用户（本例中的 h1 主机 10.0.0.1）首先发起一个与服务器的 TCP 连接，一旦连接建立，客户端和服务器进程就可以通过套接字接口访问 TCP。在本例中，这个连接的发起和响应于 5, 6 两个包：

![image-20190313220539574](/Users/zhengyu/Documents/课件/网络实验/资源/image-20190313220539574.png)

接下来就是主机发出的 HTTP 请求。一下是这个 HTTP 请求报文的内容：

![image-20190313220919028](/Users/zhengyu/Documents/课件/网络实验/资源/image-20190313220919028.png)

这个报文是用 ASCII 文本书写的。主要关注该报文的请求行。该请求行的方法字段是一个 GET 方法，URL 字段表示请求的对象，也比较简单，就是根目录。后接的是浏览器实现的 HTTP 版本，本例中是1.1.

再看服务器对于该 HTTP 请求作出的回应：

![image-20190313221533084](/Users/zhengyu/Documents/课件/网络实验/资源/image-20190313221533084.png)

HTTP 响应报文包含三个部分：初始状态行，首部行和实体体。实体体是报文的主要部分，包含了所请求的对象本身（在这个部分看不到，在正文部分可以看见一个完整的 HTML 文本）。状态行有3个字段：协议版本字段、状态码和相应状态信息。在本例中，版本是1.1，并且一切正常。

首部行内容有些多，Server 表示该报文是由一台 Apache Web 服务器产生的，它类似于 HTTP 请求报文中的 User-agent。Content-Length 和 Content-Type 分别指示被发送对象的字节数和类型，本例中，发送对象是一个 html 文本。

wireshark 自带 follow stream 功能，可以跟踪整个 TCP 连接的传输流：

![image-20190313222703211](/Users/zhengyu/Documents/课件/网络实验/资源/image-20190313222703211.png)

这里展示的内容分别是我刚才分析过的 HTTP 请求报文、HTTP 响应报文和请求对象（一个 html 文本）。

最后，通过 wireshark 所展示的结构可以发现，这些协议是一层一层封装的：

![image-20190313223038862](/Users/zhengyu/Documents/课件/网络实验/资源/image-20190313223038862.png)

## 流完成时间实验

### 实验内容

利用 python 脚本构建网络拓扑，并调研解释流完成时间图。

### 实验流程

编写（可以直接 copy 讲义代码）python 脚本，运行以搭建 mininet 虚拟网络拓扑。启动两个节点，一个用于制作本地文件，另一个通过 mininet 来请求文件。变换参数反复试验，观察结果。

### 实验结果及分析

一下为多组实验结果截图（在实验中，我没有给文件重命名，所以1MB.dat的大小不一定为1MB，具体大小以后面的数字为准）：

带宽为10Mbps：

![image-20190313230054821](/Users/zhengyu/Documents/课件/网络实验/资源/image-20190313230054821.png)

![image-20190313230211954](/Users/zhengyu/Library/Application Support/typora-user-images/image-20190313230211954.png)

![image-20190313230714449](/Users/zhengyu/Documents/课件/网络实验/资源/image-20190313230714449.png)

带宽为100Mbps：

![image-20190313232617101](/Users/zhengyu/Documents/课件/网络实验/资源/image-20190313232617101.png)

![image-20190313232639753](/Users/zhengyu/Documents/课件/网络实验/资源/image-20190313232639753.png)

![image-20190313232909523](/Users/zhengyu/Documents/课件/网络实验/资源/image-20190313232909523.png)

带宽为1Gbps：

![image-20190313233010466](/Users/zhengyu/Documents/课件/网络实验/资源/image-20190313233010466.png)

![image-20190313233029527](/Users/zhengyu/Documents/课件/网络实验/资源/image-20190313233029527.png)

![image-20190313233051606](/Users/zhengyu/Documents/课件/网络实验/资源/image-20190313233051606.png)

![image-20190313233215940](/Users/zhengyu/Documents/课件/网络实验/资源/image-20190313233215940.png)

实验结果和上图基本吻合。

传输速度和带宽正相关，但不是成正比，原因在于 TCP 传输机制。在第一个实验中已经分析过 TCP 的传输，造成与带宽关系不大的不确定时延的一个原因在于：在发送的数据包中，第一对必定是请求和确认应答（ACK），这两个包很小，占用的时间和带宽关联不大。

在连接建立的初期，如果窗口比较大，发送方可能会突然发送大量数据，导致网络瘫痪。因此，在通信一开始时，TCP 会通过慢启动算法得出窗口的大小，对发送数据量进行控制。流量控制是由发送方和接收方共同控制的。接收方会把自己能够承受的最大窗口长度写在 TCP 首部中，实际上在发送方这里，也存在流量控制，它叫拥塞窗口。

对于本例中的情况，在带宽上升到一定值后，FCT 增长的相对值变得缓慢。以下以 cwnd 记拥塞窗口，ssthresh 记门限值。当 cwnd < ssthresh 时，cwnd 随 ACK 线性提升，随 RTT 指数上升。当 cwnd >= ssthresh 后，进入拥塞避免算法，cwnd 随 RTT 线性增加。

## 感想

第一次实验动手内容比较简单，也没有需要自己动手编写的代码。但实验涉及的知识很多，我花了很多时间学习关于 ARP, TCP, HTTP 和 DNS 的知识。对于后半部分实验，TCP 的慢启动机制我甚至并没有完全弄清楚，交付报告后会再抽时间解决遗留问题。